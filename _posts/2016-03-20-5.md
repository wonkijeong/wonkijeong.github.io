---
layout: post
title: 입문자의 눈으로 본 Objective C
---

---
## 1. 들어가며
어쩌다 보니 iOS 앱 개발 업무를 맡게 되어 objective C를 공부하고 있다. 12년동안 초/중/고등학교에서 공부하고, 13년동안 대학교에서 공부(하는 시늉을)했고, 입사를 했더니 9주간 교육을 받았는데 (물론 어디서도 접할 수 없는 멋진 교육이었지만!) 또 공부를 하고 있다. 슬프다.

어쨌든 Objective C는 아직 생소하고, 기초적인 연습문제들만 풀어보고 있는 단계지만, 지금까지 느낀 바를 간략히 적어보고자 한다.

---

## 2. 기본은 C++
이름에도 들어가있듯이 기본적인 문법은 C++과 같다. (Objective C++이 아니라 C이지만, ++가 Objective로 대체되었다고 생각하면 틀린 얘긴 아닌 듯) 헤더 파일과 구현 파일이 분리되어 있고, 포인터와 매크로가 난무한다.

---

## 3. 동적 언어!?
처음 접했을 때 가장 특이하다고 할 수 있는 점은 역시 객체에 메시지를 전달하는 방식으로 메서드 콜이 일어난다는 점이다.

```objc
Fraction* fraction = [[Fraction alloc] init]
[fraction print]
```

첫 번째 줄에서 Fraction 포인터인 fraction을 선언하고, Fraction의 클래스 메서드 (자바의 스태틱 메서드)인 alloc을 호출하여 메모리를 할당받고, 그 객체에 다시 init을 호출해서 초기화를 수행한다. 그리고 두 번째 줄에서 fraction 객체의 print 함수를 호출하는 코드이다.

그런데, 저렇게 호출하는 방식이 C++이나 자바에서처럼 멤버 함수를 호출하는 것과 다른 개념인데, [fraction print]라 하면 fraction 객체에 'print'라는 메시지를 보내는 것이다. 만약 print라는 메서드가 Fraction에 없다면 컴파일 에러가 나기 때문에 실제 멤버 함수 호출과 같다고 생각할 수 있지만...

---

### id 타입
Objective C에 id 타입이라는 녀석이 있다. 쉽게 말하면 JavaScript의 var 같은 녀석이다. 아무 타입이나 들어갈 수가 있는 것이다 ㅠㅠ

아까의 예제에서 Fraction에 print가 없으면 컴파일 에러가 되지만,

```objc
id fraction = [[Fraction alloc] init]
[fraction print]
```

id 타입에 대한 메서드 호출에 대해서는 컴파일러가 감지할 수 없어서 에러가 발생하지 않는다! 직접 해보진 않았지만 저렇게 하면 그냥 경고만 표시하고 무시된다고 하는데... 무시무시한 삽질의 가능성이 보인다.
(그런데 위와 같이 간단한 케이스에서는 정적 분석으로 컴파일 에러를 발생시켜 주는 것 같다. 더 자세히 알아봐야겠다.)

---

## 4. Java와 닮은 점도 있는 것 같다?
그런데 실제 코딩을 할 때 저런 방식으로 쓰지는 않는 것 같다. Objective C에는 **protocol**이라는 녀석이 있는데, 이 녀석은 Java의 interface와 비슷하다. 즉, 함수의 목록들만 나열되어 있고, 이 protocol을 **따르는** 클래스들은 protocol에서 명시된 함수들을 다 구현해주어야 한다. 그렇게 구현이 되었다면

```objc
id<printable> fraction = [[Fraction alloc] init]
[fraction print]
```

위와 같은 방식으로 id의 범위를 좁힐 수 있다. 근데 그렇다 해도 protocol 외의 다른 메서드 호출을 할 수도 있는 것이고, 심지어 protocol에는 @optional이라는 항목이 있어서 선택적인 메서드는 다 구현 안해도 된다. 그렇기 때문에 사실 그냥 동적 언어와 큰 차이는 없지만, 그래도 저렇게 범위를 좁혀서 구현할 수 있다는게 어디인가.

그리고 자바와 비슷하게 런타임이 존재하고, 런타임에서 많은 부분을 해결한다고 한다. 그리고 가비지 컬렉터가 존재한다. (정확히는 가비지 컬렉터는 아니라고 하는데, 어쨌든 ARC(automatic reference counting) 기법을 써서 참조가 없는 메모리 영역을 자동으로 해제해 준다고 한다.)

---

## 5. 결론
아직까지는 잘 모르겠다. C++/Java/JavaScript를 적절히 짬뽕해 놓은 것 같은데, 각각의 장점만을 합친 것이라고 보긴 어려운 것 같고, 쓰는 사람의 능력에 따라서 결과물의 차이가 크게 날 것 같은 언어라는 생각이 든다. 

일단 나 같은 경우에는 깊게 파 보진 않았지만 몇 가지 언어들에 대해 접한 시간이 어느 정도 되니까 적절히 장단점을 구별해 가며 잘 써 볼 수 있을 것 같지만, 프로그래밍 입문자가 처음 접하는 언어로서는 좋지 않은 것 같다.

처음 문법들을 간략히 보고 나서, LLVM이 런타임으로 수행될 때의 장점들(런타임 확장성, 낮은 레벨의 중간 코드로 인한 네이티브 수준의 런타임 성능)이 그대로 적용된다면 정말 괜찮은 언어일 것이라는 생각이 들었는데, 대충 찾아보니 그런 장점들은 Swift에나 적용될 것 같다. 아마도 애플에서 Objective C에 LLVM을 적용할 의도로 크리스 래트너를 영입했지만, 잘 안되니까 아예 새로운 언어인 Swift를 개발한 것이 아닐까 하는 생각이 든다.

---
